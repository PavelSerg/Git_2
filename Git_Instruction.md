![git.0-1024x638.jpg](git.0-1024x683.jpg)
# Работа с Git

## 1. Проверка наличия установленного Git

В терминале выполнить команду `git version`.
Если **Git** установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## 2. Установка Git
Загружаем последнюю версию **Git** с [сайта](https://git-scm.com/downloads) или сайта https://git-scm.com/downloads 

## 3. Настройка Git
При первом использовании **Git** необходимо представиться. Для этого нужно ввести в терминале две команды:
```
git config --global user.name "Ваше имя"
git config --global user.email "Ваш email"
```
## 4. Создание Git-репозитория
Для создания **Git-репозитория** вы можете использовать два основных подхода. Во-первых,
импорт в **Git** уже существующего проекта или директории. Во-вторых, клонирование
существующего репозитория с другого сервера.
### `Создание репозитория в существующей директории`
Если вы собираетесь начать использовать **Git** для существующего проекта, то вам
необходимо перейти в директорию проекта и в командной строке ввести
```
 git init
```
Эта команда создаёт в текущей директории новую поддиректорию с именем `.git`,
содержащую все необходимые файлы репозитория — основу **Git-репозитория**. На этом этапе
ваш проект ещё не находится под версионным контролем. 
Если вы хотите добавить под версионный контроль существующие файлы (в отличие от
пустого каталога), вам стоит добавить их в индекс и осуществить первый коммит
изменений. Добиться этого вы сможете запустив команду `git add` несколько раз, указав
индексируемые файлы, а затем выполнив `git commit`:
```
git add *.c
git add LICENSE
git commit -m 'initial project version'
```
Мы разберем, что делают эти команды чуть позже. Теперь у вас есть **Git-репозиторий** с
отслеживаемыми файлами и начальным коммитом.
### `Клонирование существующего репозитория`
Для получения копии существующего **Git-репозитория**, например, проекта, в который вы
хотите внести свой вклад, необходимо использовать команду `git clone`. Если вы знакомы с другими системами контроля версий, такими как *Subversion*, то заметите, что команда
называется `"clone"`, а не `"checkout"`. Это важное различие – вместо того, чтобы просто
получить рабочую копию, **Git** получает копию практически всех данных, которые есть на
сервере. При выполнении `git clone` с сервера забирается `(pulled)` каждая версия каждого
файла из истории проекта. Фактически, если серверный диск выйдет из строя, вы можете
использовать любой из клонов на любом из клиентов, для того, чтобы вернуть сервер в то
состояние, в котором он находился в момент клонирования (вы можете потерять часть
серверных перехватчиков `(server-side hooks)` и т.п., но все данные, помещённые под
версионный контроль, будут сохранены.

Клонирование репозитория осуществляется командой `git clone` [url]. Например, если вы
хотите клонировать библиотеку `libgit2`, вы можете сделать это следующим образом:
```
git clone https://github.com/libgit2/libgit2
 ```
 Эта команда создаёт директорию `“libgit2”`, инициализирует в ней поддиректорию `.git`,
скачивает все данные для этого репозитория и создаёт `(checks out)` рабочую копию
последней версии. Если вы зайдёте в новую директорию `libgit2`, то увидите в ней файлы
проекта, готовые для работы или использования. Для того, чтобы клонировать репозиторий
в директорию с именем, отличающимся от `“libgit2”`, необходимо указать желаемое имя, как
параметр командной строки:
```
git clone https://github.com/libgit2/libgit2 mylibgit
```
Эта команда делает всё то же самое, что и предыдущая, только результирующий каталог
будет назван `mylibgit`.

В **Git’е** реализовано несколько транспортных протоколов, которые вы можете использовать.
В предыдущем примере использовался протокол `https://`, вы также можете встретить `git://`
или `user@server:path/to/repo.git`, использующий протокол передачи `SSH`. 
**Git** на сервер мы познакомимся со всеми доступными вариантами конфигурации сервера
для обеспечения доступа к вашему **Git-репозиторию**, а также рассмотрим их достоинства и
недостатки.

# 5. Запись изменений в репозиторий 
Итак, у вас имеется настоящий **Git-репозиторий** и рабочая копия файлов для некоторого
проекта. Вам нужно делать некоторые изменения и фиксировать `“снимки”` состояния
`(snapshots)` этих изменений в вашем репозитории каждый раз, когда проект достигает
состояния, которое вам хотелось бы сохранить.
Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух
состояний: под версионным контролем `(отслеживаемые)` и нет `(неотслеживаемые)`.
`Отслеживаемые файлы` — это те файлы, которые были в последнем слепке состояния
проекта `(snapshot)`; они могут быть *неизменёнными, изменёнными или подготовленными* к коммиту `(staged)`. `Неотслеживаемые файлы` — это всё остальное, любые файлы в вашем
рабочем каталоге, которые не входили в ваш последний слепок состояния и не
подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут
отслеживаемыми и неизменёнными, потому что вы только взяли их из хранилища `(checked
them out)` и ничего пока не редактировали.

Как только вы отредактируете файлы, **Git** будет рассматривать их как изменённые, т.к. вы
изменили их с момента последнего коммита. Вы индексируете `(stage)` эти изменения и
затем фиксируете все индексированные изменения, а затем цикл повторяется.

### `Определение состояния файлов`
Основной инструмент, используемый для определения, какие файлы в каком состоянии
находятся — это команда `git status`. Если вы выполните эту команду сразу после
клонирования, вы увидите что-то вроде этого:
```
git status
On branch master
nothing to commit, working directory clean
```
Это означает, что у вас чистый рабочий каталог, другими словами – в нем нет
отслеживаемых измененных файлов. **Git** также не обнаружил неотслеживаемых файлов, в
противном случае они бы были перечислены здесь. Наконец, команда сообщает вам на
какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере. Пока
что это всегда ветка `master`, ветка по умолчанию; в этой главе это не важно. В
Ветвление в **Git** будут рассмотрены ветки и ссылки более детально.
Предположим, вы добавили в свой проект новый файл, простой файл `README`. Eсли этого
файла раньше не было, и вы выполните `git status`, вы увидите свой неотслеживаемый файл
вот так:
```
echo 'My Project' > README              git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)
  README
nothing added to commit but untracked files present (use "git add" to track)
```
Понять, что новый файл `README` неотслеживаемый можно по тому, что он находится в
секции `Untracked files` в выводе команды ``status``. Статус `Untracked files`, по сути,
означает, что **Git** видит файл, отсутствующий в предыдущем снимке состояния (коммите);
**Git** не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это
предохранит вас от случайного добавления в репозиторий сгенерированных бинарных
файлов или каких-либо других, которые вы и не думали добавлять. Мы хотели добавить
`README`, так давайте сделаем это.

### `Отслеживание новых файлов`
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл,
используется команда `git add`. Чтобы начать отслеживание файла `README`, вы можете
выполнить следующее:
```
git add README
```
Если вы снова выполните команду `status`, то увидите, что файл `README` теперь
отслеживаемый и индексированный:

```
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
```
Вы можете видеть, что файл проиндексирован по тому, что он находится в секции
`Changes to be committed`. Если вы выполните коммит в этот момент, то версия файла,
существовавшая на момент выполнения вами команды `git add`, будет добавлена в историю
снимков состояния. Как вы помните, когда вы ранее выполнили `git init`, затем вы
выполнили `git add` (файлы) — это было сделано для того, чтобы добавить файлы в вашем
каталоге под версионный контроль. Команда `git add` принимает параметром путь к файлу
или каталогу, если это каталог, команда рекурсивно добавляет (индексирует) все файлы в
данном каталоге.
### `Индексация изменённых файлов`
Давайте модифицируем файл, уже находящийся под версионным контролем. Если вы
измените отслеживаемый файл `CONTRIBUTING.md` и после этого снова выполните
команду `git status`, то результат будет примерно следующим:
```
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
  ```
  Файл ``CONTRIBUTING.md`` находится в секции ``Changes not staged for commit`` — это
означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не
проиндексирован. Чтобы проиндексировать его, необходимо выполнить команду `git add`.
Это многофункциональная команда, она используется для добавления под версионный
контроль новых файлов, для индексации изменений, а также для других целей, например
для указания файлов с исправленным конфликтом слияния. Вам может быть понятнее,
если вы будете думать об этом как `добавить этот контент в следующий коммит`, а не
как `добавить этот файл в проект`. Выполним `git add`, чтобы проиндексировать
`CONTRIBUTING.md`, а затем снова выполним `git status`:
```
git add CONTRIBUTING.md                 git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
  modified: CONTRIBUTING.md
  ```
Теперь оба файла проиндексированы и войдут в следующий коммит. В этот момент вы,
предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в
``CONTRIBUTING.md`` до коммита. Вы открываете файл, вносите и сохраняете
необходимые изменения и вроде бы готовы к коммиту. Но давайте-ка ещё раз выполним `git
status`:
```
vim CONTRIBUTING.md                   git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
  modified: CONTRIBUTING.md
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
  ```
 Что за чёрт? Теперь ``CONTRIBUTING.md`` отображается как проиндексированный и
непроиндексированный одновременно. Как такое возможно? Такая ситуация наглядно
демонстрирует, что **Git** индексирует файл в точности в том состоянии, в котором он
находился, когда вы выполнили команду `git add`. Если вы выполните коммит сейчас, то
файл ``CONTRIBUTING.md`` попадёт в коммит в том состоянии, в котором он находился,
когда вы последний раз выполняли команду `git add` , а не в том, в котором он находится в
вашем рабочем каталоге в момент выполнения `git commit`. Если вы изменили файл после
выполнения `git add`, вам придётся снова выполнить `git add`, чтобы проиндексировать
последнюю версию файла:
```
git add CONTRIBUTING.md
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
  modified: CONTRIBUTING.md
  ```
### `Сокращенный вывод статуса`
Вывод команды `git status` довольно всеобъемлющий и многословный. **Git** также имеет флаг
вывода сокращенного статуса, так что вы можете увидеть изменения в более компактном
виде. Если вы выполните `git status -s` или `git status --short` вы получите гораздо более
упрощенный вывод.
```
git status -s
 M README
MM Rakefile
A lib/git.rb
M lib/simplegit.rb
?? LICENSE.txt
```
Новые, неотслеживаемые файлы помечены `??` слева от них, файлы добавленные в
отслеживаемые помечены `A`, отредактированные файлы помечены `M` и так далее. В выводе
содержится два столбца - в левом указывается статус файла, а в правой модифицирован ли
он после этого. К примеру в нашем выводе, файл `README` модифицирован в рабочей
директории и не проиндексирован, файл `lib/simplegit.rb` модифицирован и
проиндексирован. Файл `Rakefile` модифицирован, проиндексирован и ещё раз
модифицирован, таким образом на данный момент у него есть изменения которые попадут
в коммит и те которые не попадут.
### `Игнорирование файлов`
Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически
добавлять в репозиторий, но и видеть в списках неотслеживаемых. К таким файлам обычно
относятся автоматически генерируемые файлы (различные логи, результаты сборки
программ и т.п.). В таком случае, вы можете создать файл `.gitignore.` с перечислением
шаблонов соответствующих таким файлам. Вот пример файла `.gitignore`:
```
cat .gitignore
*.[oa]
*~
```
Первая строка предписывает **Git** игнорировать любые файлы заканчивающиеся на ``.o``
или ``.a`` - объектные и архивные файлы, которые могут появиться во время сборки кода.
Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду `(~)`,
которая используется во многих текстовых редакторах, например `Emacs`, для обозначения
временных файлов. Вы можете также включить каталоги `log, tmp` или `pid`; автоматически
создаваемую документацию; и т.д. и т.п. Хорошая практика заключается в настройке файла
`.gitignore` до того, как начать серьёзно работать, это защитит вас от случайного добавления
в репозиторий файлов, которых вы там видеть не хотите.
К шаблонам в файле `.gitignore` применяются следующие правила:
• Пустые строки, а также строки, начинающиеся с `#`, игнорируются.
• Можно использовать стандартные `glob шаблоны`.
• Можно начать шаблон символом слэша `(/)` чтобы избежать рекурсии.
• Можно заканчивать шаблон символом слэша `(/)` для указания каталога.
• Можно инвертировать шаблон, использовав восклицательный знак `(!)` в качестве
первого символа.

`Glob-шаблоны` представляют собой упрощённые регулярные выражения, используемые
командными интерпретаторами. Символ `(*)` соответствует 0 или более символам;
последовательность `[abc]` — любому символу из указанных в скобках `(в данном примере a,
b или c)`; знак вопроса `(?)` соответствует одному символу; и квадратные скобки, в которые
заключены символы, разделённые дефисом (`[0-9]`), соответствуют любому символу из
интервала (в данном случае от 0 до 9). Вы также можете использовать две звёздочки, чтобы
указать на вложенные директории: `a/**/z соответствует a/z, a/b/z, a/b/c/z`, и так далее.
Вот ещё один пример файла `.gitignore`:
```
# no .a files
*.a
# but do track lib.a, even though you're ignoring .a files above
!lib.a
# only ignore the root TODO file, not subdir/TODO
/TODO
# ignore all files in the build/ directory
build/
# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt
```
TIP
**GitHub** поддерживает довольно полный список примеров `.gitignore` файлов для
множества проектов и языков https://github.com/github/gitignore это может стать
отправной точкой для `.gitignore` в вашем проекте.
### `Просмотр индексированных и неиндексированных изменений`
Если результат работы команды `git status` недостаточно информативен для вас — вам
хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы
можете использовать команду `git diff`. Позже мы рассмотрим команду `git diff` подробнее;
вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса:
что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь
фиксировать. Если `git status` отвечает на эти вопросы в самом общем виде, перечисляя
имена файлов, `git diff` показывает вам непосредственно добавленные и удалённые строки
— собственно заплатку (patch).
Допустим, вы снова изменили и проиндексировали файл `README`, а затем изменили файл
`CONTRIBUTING.md` без индексирования. Если вы выполните команду `git status`, вы опять
увидите что-то вроде:
```
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  new file: README
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
  ```
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите `git diff` без
аргументов:
```
git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
```
Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса.
Результат показывает ещё не проиндексированные изменения.
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит,
вы можете выполнить `git diff --staged`. Эта команда сравнивает ваши индексированные
изменения с последним коммитом:
```
git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
```
Важно отметить, что `git diff` сама по себе не показывает все изменения сделанные с
последнего коммита — только те, что ещё не проиндексированы. Такое поведение может
сбивать с толку, так как если вы проиндексируете все свои изменения, то `git diff` ничего не
вернёт.
Другой пример: вы проиндексировали файл `CONTRIBUTING.md` и затем изменили его, вы
можете использовать `git diff` для просмотра как индексированных изменений в этом
файле, так и тех, что пока не проиндексированы. В нашем случае это будет выглядеть вот
так:
```
 git add CONTRIBUTING.md
 echo 'test line' >> CONTRIBUTING.md
 git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  modified: CONTRIBUTING.md
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
  ```
 Теперь вы можете используя `git diff` посмотреть непроиндексированные изменения 
 ```
git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects
 See our [projects
list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
```
а также уже проиндексированные, используя `git diff --cached (--staged и --cached
синонимы)`:
```
git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.
 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
 ```
### `Коммит изменений`
Теперь, когда ваш индекс находится в таком состоянии, как вам и хотелось, вы можете
зафиксировать свои изменения. Запомните, всё, что до сих пор не проиндексировано —
любые файлы, созданные или изменённые вами, и для которых вы не выполнили `git add`
после момента редактирования — не войдут в этот коммит. Они останутся изменёнными
файлами на вашем диске. В нашем случае, когда вы в последний раз выполняли `git status`,
вы видели что всё проиндексировано, и вот, вы готовы к коммиту. Простейший способ
зафиксировать изменения — это набрать `git commit`:
```
git commit
```
Эта команда откроет выбранный вами текстовый редактор. (Редактор устанавливается
системной переменной `$EDITOR` — обычно это `vim` или `emacs`, хотя вы можете установить
ваш любимый с помощью команды `git config --global core.editor`).
В редакторе будет отображён следующий текст (это пример окна `Vim’а`):
```
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
# new file: README
# modified: CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
```
Вы можете видеть, что комментарий по умолчанию для коммита содержит
закомментированный результат работы (`"выхлоп"`) команды `git status` и ещё одну пустую
строку сверху. Вы можете удалить эти комментарии и набрать своё сообщение или же
оставить их для напоминания о том, что вы фиксируете. (Для ещё более подробного
напоминания, что же именно вы поменяли, можете передать аргумент `-v` в команду `git
commit`. Это приведёт к тому, что в комментарий будет также помещена `дельта/diff`
изменений, таким образом вы сможете точно увидеть все изменения которые вы
совершили.) Когда вы выходите из редактора, **Git** создаёт для вас коммит с этим сообщением
(удаляя комментарии и вывод `diff’а`).
Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной
строке вместе с командой `commit` указав его после параметра `-m`, как в следующем примере:
```
git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
 ```
Итак, вы создали свой первый коммит! Вы можете видеть, что коммит вывел вам немного
информации о себе: на какую ветку вы выполнили коммит (`master`), какая контрольная
сумма `SHA-1` у этого коммита (`463dc4f`), сколько файлов было изменено, а также статистику
по добавленным/удалённым строкам в этом коммите.
Запомните, что коммит сохраняет снимок состояния вашего индекса. Всё, что вы не
проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё
один коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете
коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете
восстановить или с которым можно сравнить текущее состояние.
### `Игнорирование индексации`
Несмотря на то, что индекс может быть удивительно полезным для создания коммитов
именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в
процессе работы. Если у вас есть желание пропустить этап индексирования, **Git**
предоставляет простой способ. Добавление параметра `-a` в команду `git commit` заставляет **Git**
автоматически индексировать каждый уже отслеживаемый на момент коммита файл,
позволяя вам обойтись без `git add`:
```
git status
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
no changes added to commit (use "git add" and/or "git commit -a")
git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
 ```
 Обратите внимание на то, что в данном случае перед коммитом вам не нужно выполнять
`git add` для файла ``CONTRIBUTING.md``.

### `Удаление файлов`
Для того чтобы удалить файл из **Git**, вам необходимо удалить его из отслеживаемых файлов
(точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать
команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что вы в
следующий раз не увидите его как `“неотслеживаемый”`.
Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции
``Changes not staged for commit`` (измененные, но не проиндексированные) вывода
команды `git status`:
```
rm PROJECTS.md
git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  deleted: PROJECTS.md
no changes added to commit (use "git add" and/or "git commit -a")
```
Затем, если вы выполните команду `git rm`, удаление файла попадёт в индекс:
```
git rm PROJECTS.md
rm 'PROJECTS.md'
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  deleted: PROJECTS.md
```
После следующего коммита файл исчезнет и больше не будет отслеживаться. Если вы
изменили файл и уже проиндексировали его, вы должны использовать принудительное
удаление с помощью параметра `-f`. Это сделано для повышения безопасности, чтобы
предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок
состояния и которые нельзя восстановить из **Git**.
Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из
индекса, оставив его при этом в рабочем каталоге. Другими словами, вы можете захотеть
оставить файл на жёстком диске, и убрать его из-под бдительного ока **Git**. Это особенно
полезно, если вы забыли добавить что-то в файл `.gitignore` и по ошибке проиндексировали,
например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы
сделать это, используйте опцию `--cached`:
```
git rm --cached README
```
В команду `git rm` можно передавать файлы, каталоги или `glob-шаблоны`. Это означает, что
вы можете вытворять что-то вроде:
```
git rm log/\*.log
```
Обратите внимание на обратный слэш `(\)` перед `*`. Он необходим из-за того, что **Git**
использует свой собственный обработчик имён файлов вдобавок к обработчику вашего
командного интерпретатора. Эта команда удаляет все файлы имеющие расширение `.log`
находящиеся в директории `log/.` Или же вы можете сделать вот так:
```
 git rm \*~
 ```
 Эта команда удаляет все файлы, чьи имена заканчиваются на `~`.
### `Просмотр истории коммитов`
После того, как вы создали несколько коммитов или же склонировали репозиторий с уже
существующей историей коммитов, вероятно вам понадобится возможность посмотреть
что было сделано – историю коммитов. Одним из основных и наиболее мощных
инструментов для этого является команда `git log`.
Следующие несколько примеров используют очень простой проект `“simplegit”`. Чтобы
склонировать проект, используйте команду:
```
git clone https://github.com/schacon/simplegit-progit
```
Если вы запустите команду `git log` в папке склонированного проекта, вы увидите
следующий вывод:
```
git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
  changed the version number
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
  removed unnecessary test
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 10:31:28 2008 -0700
  first commit
```
По умолчанию (без аргументов) `git log` перечисляет коммиты, сделанные в репозитории в
обратном к хронологическому порядке – последние коммиты находятся вверху. Из примера
можно увидеть, что данная команда перечисляет коммиты с их `SHA-1` контрольными
суммами, именем и электронной почтой автора, датой создания и сообщением коммита.
Команда `git log` имеет очень большое количество опций для поиска коммитов по разным
критериям. Рассмотрим наиболее популярные из них.
Одним из самых полезных аргументов является `-p`, который показывает разницу,
внесенную в каждый коммит. Так же вы можете использовать аргумент `-2`, который
позволяет установить лимит на вывод количества коммитов. В данном случае их будет
только два:
```
git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
  changed the version number
diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
--- a/Rakefile
+++ b/Rakefile
@@ -5,7 +5,7 @@ require 'rake/gempackagetask'
 spec = Gem::Specification.new do |s|
  s.platform = Gem::Platform::RUBY
  s.name = "simplegit"
- s.version = "0.1.0"
+ s.version = "0.1.1"
  s.author = "Scott Chacon"
  s.email = "schacon@gee-mail.com"
  s.summary = "A simple gem for using Git in Ruby code."
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
  removed unnecessary test
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
  end
 end
-
-if $0 == __FILE__
- git = SimpleGit.new
- puts git.show
-end
\ No newline at end of file
``
Эта опция отображает аналогичную информацию но содержит разницу для каждой записи.
Очень удобно использовать данную опцию для код ревью или для быстрого просмотра
серии изменений. Так же есть возможность использовать серию опций для обобщения.
Например, если вы хотите увидеть сокращенную статистику для каждого коммита, вы
можете использовать опцию `--stat` :
```                                    git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon <schacon@gee-mail.com>
Date: Mon Mar 17 21:52:11 2008 -0700
  changed the version number
 Rakefile | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 16:40:33 2008 -0700
  removed unnecessary test
 lib/simplegit.rb | 5 -----
 1 file changed, 5 deletions(-)
commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon <schacon@gee-mail.com>
Date: Sat Mar 15 10:31:28 2008 -0700
  first commit
 README | 6 ++++++
 Rakefile | 23 +++++++++++++++++++++++
 lib/simplegit.rb | 25 +++++++++++++++++++++++++
 3 files changed, 54 insertions(+)
```
Как вы видите, опция `--stat` печатает под каждым из коммитов список и количество
измененных файлов, а также сколько строк в каждом из файлов было добавлено и удалено.
В конце можно увидеть суммарную таблицу изменений.
Следующей действительно полезной опцией является `--pretty`. Эта опция меняет формат
вывода. Существует несколько встроенных вариантов отображения. Например, опция
`oneline` печатает каждый коммит в одну строку, что может быть очень удобным если вы
просматриваете большое количество коммитов. К тому же, опции `short, full и fuller` делают
вывод приблизительно в том же формате, но с меньшим или большим количеством
информации соответственно:
```
git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
```
Наиболее интересной опцией является `format`. Она позволяет создать свой формат для
вывода информации. Особенно это может быть полезным когда вы хотите сгенерировать вывод для автоматического анализа – так как вы указываете формат явно, он не будет
изменен даже после обновления **Git**:
```
git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit
```
### `Операции отмены`
В любой момент вам может потребоваться что-либо отменить. Здесь мы рассмотрим
несколько основных способов отмены сделанных изменений. Будьте осторожны, не все
операции отмены в свою очередь можно отменить! Это одна из редких областей **Git’а**, где
неверными действиями можно необратимо удалить результаты своей работы.
Отмена может потребоваться, если вы сделали коммит слишком рано, например, забыв
добавить какие-то файлы или комментарий к коммиту. Если вы хотите переделать коммит,
можно запустить `commit` с параметром `--amend` (дополнить):
```
git commit --amend
```
Эта команда использует для дополнения коммита вашу область подготовки (индекс). Если
вы ничего не меняли с момента последнего коммита (например, команда запущена сразу
после предыдущего коммита), то снимок состояния останется в точности таким же, а
изменится лишь комментарий к коммиту.
Запустится тот же редактор комментария к коммиту, но уже с комментарием к
предыдущему коммиту. Комментарий можно отредактировать точно так же, как обычно,
просто он заменит собой предыдущий Например, если вы фиксируете изменения, и понимаете, что забыли проиндексировать
изменения в файле, который хотели включить в коммит, можно сделать примерно так:
```
git commit -m 'initial commit'
git add forgotten_file
git commit --amend
```

В итоге получится единый коммит — второй коммит заменит результаты первого.

### ``Отмена подготовки файла``
В следующих двух разделах показано, как разбираться с изменениями вашей области
подготовки `(staging area)` и рабочего каталога. Радует, что команда, которой вы определяете
состояние этих областей, также напоминает вам, как отменять их изменения. Например,
скажем, вы изменили два файла, и хотите закоммитить их двумя раздельными
изменениями, но случайно набрали `git add *`, и добавили оба в индекс. Как отменить
добавление одного из них? Команда `git status` напомнит вам:
```
git add .
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  renamed: README.md -> README
  modified: CONTRIBUTING.md  
```

Прямо под текстом `“Changes to be committed”` говорится: `git reset HEAD <file>...` для отмены
добавления в индекс. Давайте последуем этому совету, и отменим индексирование файла
`CONTRIBUTING.md`:
```
git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M CONTRIBUTING.md
git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)
  renamed: README.md -> README
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)
  modified: CONTRIBUTING.md
```
# 6. Работа с удалёнными репозиториями
Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с
удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего
проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько
удалённых репозиториев, каждый из которых может быть доступен для чтения или для
чтения-записи. Взаимодействие с другими пользователями предполагает управление
удалёнными репозиториями, а также отправку и получение данных из них. Управление
репозиториями включает в себя как умение добавлять новые, так и умение удалять
устаревшие репозитории, а также умение управлять различными удалёнными ветками,
объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим
некоторые из этих навыков.
## `Просмотр удалённых репозиториев`
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете
запустить команду `git remote`. Она выведет названия доступных удалённых репозиториев.
Если вы клонировали репозиторий, то увидите как минимум ``origin`` — имя по
умолчанию для исходного репозитория:
```
умолчанию для исходного репозитория:
git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
```
Вы можете также указать ключ `-v`, чтобы просмотреть адреса для чтения и записи,
привязанные к репозиторию:
```
git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
```
Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для
репозитория с несколькими настроенными удалёнными репозиториями в случае
совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:
```
cd grit
git remote -v
bakkdoor https://github.com/bakkdoor/grit (fetch)
bakkdoor https://github.com/bakkdoor/grit (push)
cho45 https://github.com/cho45/grit (fetch)
cho45 https://github.com/cho45/grit (push)
defunkt https://github.com/defunkt/grit (fetch)
defunkt https://github.com/defunkt/grit (push)
koke git://github.com/koke/grit.git (fetch)
koke git://github.com/koke/grit.git (push)
origin git@github.com:mojombo/grit.git (fetch)
origin git@github.com:mojombo/grit.git (push)
```
Это означает, что мы можем легко получить изменения от любого из этих пользователей.
Возможно, что некоторые из репозиториев доступны для записи, и в них можно отправлять
свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.
### `Добавление удалённых репозиториев`
В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых
репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить
удалённый репозиторий и присвоить ему имя `(shortname)`, просто выполните команду `git
remote add` [shortname] [url]:
```
git remote
origin
git remote add pb https://github.com/paulboone/ticgit
git remote -v
origin https://github.com/schacon/ticgit (fetch)
origin https://github.com/schacon/ticgit (push)
pb https://github.com/paulboone/ticgit (fetch)
pb https://github.com/paulboone/ticgit (push)
```
Теперь вместо указания полного пути вы можете использовать `pb`. Например, если вы
хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить
команду `git fetch pb`:
```
git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
* [new branch] master -> pb/master
* [new branch] ticgit -> pb/ticgit 
```   

Ветка `master` из репозитория Пола сейчас доступна вам под именем `pb/master`. Вы можете
слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы
просмотреть содержимое ветки Пола. 
# 7. Псевдонимы в Git
Git не будет пытаться сделать вывод о том, какую команду вы хотели ввести, если вы ввели
её неполностью. Если вы не хотите печатать каждую команду для **Git’а** целиком, вы легко
можете настроить псевдонимы (`alias`) для любой команды с помощью `git config`. Вот
несколько примеров псевдонимов, которые вы, возможно, захотите задать:

```
 git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```
Это означает, что, например, вместо ввода `git commit`, вам достаточно набрать только `git ci`.
По мере освоения **Git’а** вам, вероятно, придётся часто пользоваться и другими командами. В
этом случае без колебаний создавайте новые псевдонимы.
Такой способ может также быть полезен для создания команд, которые, как вы думаете,
должны существовать. Например, чтобы исправить неудобство, с которым мы столкнулись
при исключении файла из индекса, можно добавить в **Git** свой собственный псевдоним
`unstage`:
```
git config --global alias.unstage 'reset HEAD --'
```
Это делает эквивалентными следующие две команды:
```
git unstage fileA
git reset HEAD -- fileA
```
Такой вариант кажется немного более понятным. Также, обычно, добавляют команду `last`
следующим образом:
```
 git config --global alias.last 'log -1 HEAD'
```
Таким образом, можно легко просмотреть последний коммит:
```
git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel <dreamer3@example.com>
Date: Tue Aug 26 19:48:51 2008 +0800
  test for current head
  Signed-off-by: Scott Chacon <schacon@example.com>
  
```
Можно сказать, что **Git** просто заменяет эти команды на созданные вами псевдонимы (`alias`).
Однако, возможно, вы захотите выполнить внешнюю команду, а не подкоманду **Git’а**`. В этом
случае, следует начать команду с символа `!`. Это полезно, если вы пишете свои утилиты для
работы с `Git-репозиторием`. Продемонстрируем этот случай на примере создания
псевдонима `git visual` для запуска `gitk`:
```
 git config --global alias.visual "!gitk"
```
## Заключение
Теперь вы умеете выполнять все базовые локальные операции с **Git’ом**: создавать или
клонировать репозиторий, вносить изменения, индексировать и фиксировать эти
изменения, а также просматривать историю всех изменений в репозитории. Дальше мы
рассмотрим `киллер-фичу` **Git’а** — его модель ветвления.

# 8. Ветвление в Git
Почти каждая система контроля версий (`СКВ`) в какой-то форме поддерживает ветвление.
Используя ветвление, Вы отклоняетесь от основной линии разработки и продолжаете
работу независимо от нее, не вмешиваясь в основную линию. Во многих `СКВ` создание веток
— это очень затратный процесс, часто требующий создания новой копии директории, что
может занять много времени для большого проекта.
Некоторые люди, говоря о модели ветвления **Git**, называют ее `“киллер-фича”`, что выгодно
выделяет **Git** на фоне остальных `СКВ`. Что в ней такого особенного? Ветвление **Git** очень
легковесно. Операция создания ветки выполняется почти мгновенно, переключение между
ветками туда-сюда, обычно, также быстро. В отличии от многих других `СКВ`, **Git** поощряет
процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько
раз в день. Понимание и владение этой функциональностью дает Вам уникальный и
мощный инструмент, который может полностью изменить привычный Вам процесс
разработки. 
## Создание новой ветки
### О ветвлении в двух словах
Для четкого понимания механизма ветвлений, необходимо вернуться назад и изучить то,
как **Git** хранит данные.
Как вы можете помнить из `Введение`, **Git** не хранит данные в виде последовательности
изменений, он использует набор снимков (`snapshot`).
Когда вы делаете коммит, **Git** сохраняет его в виде объекта, который содержит указатель на
снимок (`snapshot`) подготовленных данных. Этот объект так же содержит имя автора и
`email`, сообщение и указатель на коммит или коммиты непосредственно предшествующие
данному (`его родителей`): отсутствие родителя для первоначального коммита, один
родитель для обычного коммита, и несколько родителей для результатов слияния веток.
Представьте себе каталог, который содержит дерево файлов, и вы подготавливаете их все
вместе, а затем сохраняете в виде одного коммита. В процессе подготовки вычисляется
контрольная сумма каждого файла (`SHA-1 как мы узнали из Введение`), хранящая версию
файла в репозитории **Git** (`**Git** ссылается на них`), затем эти контрольные суммы добавляются
в область подготовленных файлов:
```
git add README test.rb LICENSE
git commit -m 'initial commit of my project'
```
Когда вы создаете коммит командой `git commit`, **Git** вычисляет контрольные суммы каждого
подкаталога (в нашем случае, только основной каталог проекта) и сохраняет эти объекты
дерева в репозитории. Затем **Git** создает объект коммита с метаданными и указателем на
основное дерево проекта для возможности воссоздать этот снимок (`snapshot`) в случае
необходимости.
Ваш репозиторий **Git** теперь хранит пять объектов: `блоб` (`blob`) для содержимого каждого
файла, содержимое каталога в виде дерева с указателями на `блобы` сохраненных фалов, сам
коммит с указателем на основное дерево, метаданные коммита.
Если вы сделаете изменения и еще один коммит, тогда следующий коммит сохранит
указатель на коммит, предшествующий ему.
Ветка (`branch`) в **Git** — это легко перемещаемый указатель на один из этих коммитов. Имя
основной ветки по умолчанию в `**Git** — master`.
Когда вы делаете коммиты, то получаете основную ветку, указывающую на ваш последний
коммит. Каждый коммит автоматически двигает этот указатель вперед.
Ветка `“master”` в **Git** — это не специальная ветка. Она точно такая же, как и
все остальные ветки. Она существует почти во всех репозиториях только
лишь потому, что ее создает команда `git init`, а большинство людей не
меняют ее название.
## Создание новой ветки
Что же на самом деле происходит, когда вы создаете ветку? Всего лишь создается новый
указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с
именем `“testing”` Вы можете это сделать командой `git branch` :
```
 git branch testing
```
В результате создается новый указатель на тот же самый коммит, в котором вы находитесь.
Как **Git** определяет, в какой ветке вы находитесь? Он хранит специальный указатель `HEAD`.
Имейте ввиду, что в **Git** концепция `HEAD` значительно отличается от других систем контроля
версий, которые вы могли использовать раньше (Subversion или CVS). В **Git** это указатель на локальную ветку, в которой вы находитесь. В нашем случае мы все еще находимся в ветке
`“master”`. Команда `git branch` только создает новую ветку. Переключения не происходит.
версий, которые вы могли использовать раньше (`Subversion или CVS`). В **Git** это указатель на
локальную ветку, в которой вы находитесь. В нашем случае мы все еще находимся в ветке
“`master`”. Команда `git branch` только создает новую ветку. Переключения не происходит.
Вы можете легко это увидеть при помощи простой команды `git log`. Она покажет вам, куда
указывают указатели веток. Эта опция называется `--decorate`.
```
git log --oneline --decorate
f30ab (HEAD, master, testing) add feature #32 - ability to add new
34ac2 fixed bug #1328 - stack overflow under certain conditions
98ca9 initial commit of my project

Видны ветки “`master`” и “`testing`”, которые указывают на коммит `f30ab`.
## Переключение веток
Чтобы переключиться на существующую ветку, выполните команду `git checkout`. Давайте
переключимся на ветку “`testing`”:
```
git checkout testing
```
В результате указатель `HEAD` переместится на ветку `testing`.
Какой в этом смысл? Давайте сделаем еще один коммит:
```
vim test.rb
git commit -a -m 'made a change'
```
Эта команда сделала две вещи. Она переместила указатель `HEAD` назад на ветку `“master”` и
вернула файлы в рабочем каталоге в то состояние, которое было сохранено в снимке
`(snapshot)`, на который указывает ветка. Это также означает, что все изменения, вносимые с
этого момента, будут отнесены к старой версии проекта. Другими словами, откатилась вся
работа, выполненная в ветке `“testing”`, а вы можете продолжать в другом направлении.
Переключение веток меняет файлы в рабочем каталоге
Это интересно, потому что указатель на вашу ветку “`testing`” переместился вперед, а
“`master`” все еще указывает на тот коммит, где вы были в момент выполнения команды `git checkout` для переключения веток. Давайте переключимся назад на ветку “`master`”:
```
git checkout master
```
Важно запомнить, что когда вы переключаете ветки в **Git**, файлы в рабочем
каталоге меняются. Если вы переключаетесь на старую ветку, то рабочий
каталог будет выглядеть так же, как выглядел на момент последнего коммита
в ту ветку. Если **Git** по каким-то причинам не может этого сделать — он не
позволит вам переключиться.
Давайте сделаем еще несколько изменений и очередной коммит:
```
vim test.rb
git commit -a -m 'made other changes'
```
Теперь история вашего проекта разделилась (см `Разветвленная история`). Вы создали ветку,
переключились в нее, поработали, а затем вернулись в основную ветку и поработали в ней.
Эти изменения изолированы друг от друга: вы можете свободно переключаться туда и
обратно, а когда будете готовы — слить их вместе. И все это делается простыми командами:
`branch, checkout `и `commit`.
Все это вы можете увидеть при помощи команды `git log`. Команда `git log --oneline --decorate --graph --all`выдаст историю ваших коммитов и покажет, где находятся
указатели ваших веток, и как ветвилась история проекта.
```
git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
```
Cоздание и удаление веток совершенно не затратно, так как ветка в **Git** — это всего лишь
файл, содержащий 40 символов контрольной суммы SHA-1 того коммита, на который он
файл, содержащий 40 символов контрольной суммы `SHA-1` того коммита, на который он
указывает. Создание новой ветки совершенно быстро и просто — это всего лишь запись 41
байта в файл (40 знаков и перевод строки).
Это совершенно отличает **Git** от ветвления в большинстве более старых систем контроля
версий, где все файлы проекта копируются в другой подкаталог. Там ветвление для
проектов разного размера может занять от секунд до минут. В **Git** ветвление всегда
мгновенное. Также, поскольку при коммите мы сохраняем указатель на родительский
коммит, найти подходящую базу для слияния в основном очень просто, и это делается для
нас автоматически. 
Давайте посмотрим, почему и вам имеет смысл делать так же.
## 8.Основы ветвления и слияния
Эти возможности побуждают разработчиков чаще создавать и
использовать ветки.
Давайте посмотрим, почему и вам имеет смысл делать так же.
## Основы ветвления и слияния
Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в
вашем проекте. Ваша работа построена так:
1. Вы работаете над сайтом.
2. Вы создаете ветку для новой статьи, которую вы пишете.
3. Вы работаете в этой ветке.
В этот момент вы получаете сообщение, что обнаружена критическая ошибка, требующая
скорейшего исправления. Ваши действия:
1. Переключиться на основную ветку.
2. Создать ветку для добавления исправления.
3. После тестирования слить ветку содержащую исправление с основной веткой.
4. Переключиться назад в ту ветку где вы пишите статью и продолжить работать.
<<<<<<< HEAD
### Основы слияния
Предположим, вы решили, что работа по проблеме `#53` закончена, и ее можно влить в ветку
`master`. Для этого нужно выполнить слияние ветки `iss53` точно так же, как вы делали это с
веткой `hotfix` ранее. Все что нужно сделать — переключиться на ветку, в которую вы хотите
включить изменения, и выполнить команду `git merge`:
```
git checkout master
Switched to branch 'master'
git merge iss53
Merge made by the 'recursive' strategy.
index.html | 1 +
1 file changed, 1 insertion(+)
```
Результат этой операции отличается от результата слияния ветки `hotfix`. В данном случае
процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы
находимся, не является прямым потомком ветки, с которой мы выполняем слияние, **Git**
придется немного потрудиться. В этом случае **Git** выполняет простое трехстороннее слияние
двух снимков (`snapshot`) сливаемых веток и общего для двух веток родительского снимка.
Вместо того, чтобы просто передвинуть указатель ветки вперед, **Git** создает новый снимок результат трехстороннего слияния, а затем автоматически делает коммит. Этот особый коммит называют коммитом слияния, так как у него более одного предка.
Стоит отметить, что Git сам определяет наилучшего общего предка, подходящего как база
для слияния; это отличает его от более старых инструментов, таких как CVS или Subversion
(до версии 1.5), где разработчикам, выполнявшим слияние, приходилось самим находить
лучшую базу. Это безумно упрощает слияние в **Git** по сравнению с указанными системами.
Теперь, когда работа влита, ветка `iss53` больше не нужна. Вы можете закрыть вопрос в
системе отслеживания ошибок и удалить ветку:
```
 git branch -d iss53
```
### Основные конфликты слияния
Иногда процесс не проходит гладко. Если вы изменили одну и ту же часть одного и того же
файла по-разному в двух объединяемых ветках, **Git** не сможет их чисто объединить. Если
ваше исправление ошибки `#53` потребовало изменить ту же часть файла, что и `hotfix`, вы
получите примерно такое сообщение о конфликте слияния:
```
git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
```
**Git** не создал коммит слияния автоматически. Он остановил процесс до тех пор, пока вы не
разрешите конфликт. Чтобы в любой момент после появления конфликта увидеть, какие
файлы не объединены, вы можете запустить `git status`:
```
git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
Unmerged paths:
  (use "git add <file>..." to mark resolution)
  both modified: index.html
no changes added to commit (use "git add" and/or "git commit -a")
```
Все, где есть неразрешенные конфликты слияния, перечисляется как неслитое. **Git**
добавляет в конфликтующие файлы стандартные пометки разрешения конфликтов, чтобы
вы могли вручную открыть их и разрешить конфликты. В вашем файле появился раздел,
выглядящий примерно так:
```
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
```
Это означает, что версия из `HEAD` (вашей ветки `master`, поскольку именно ее вы выгрузили,
запустив команду слияния) — это верхняя часть блока (все, что над `=======`), а версия из
вашей ветки `iss53` представлена в нижней части. Чтобы разрешить конфликт, придется
выбрать одну из сторон, либо объединить содержимое по-своему. Например, вы можете
разрешить конфликт, заменив весь блок этим:
```
<div id="footer">
please contact us at email.support@github.com
</div>
```
В этом разрешении есть немного от каждой части, а строки `<<<<<<<, ======= и >>>>>>>` совсем убраны. Разрешив каждый конфликт во всех файлах, запустите `git add` для каждого файла,
чтобы отметить конфликт как решенный. Подготовка (`staging`) файла помечает его для **Git**как разрешенный конфликт.
Если вы хотите использовать графический инструмент для разрешения конфликтов, можно запустить `git mergetool`, что откроет соответствующее визуальное средство, которое
проведет вас по всем конфликтам:
```
git mergetool
This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge
p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html
Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
```
Если вы хотите использовать средство слияния не по умолчанию (в данном случае **Git** выбрал `opendiff`, поскольку команда запускалась на Mac), список всех поддерживаемых
инструментов представлен вверху после фразы “`one of the following tools.`” Просто введите название инструмента, который нужно использовать.
После выхода из средства слияния **Git** спрашивает, успешно ли слияние. Если вы утвердительно ответите скрипту, он подготовит (`stage`) файл, чтобы отметить его как разрешенный. Теперь можно снова запустить `git status`, чтобы убедиться, что все
конфликты разрешены:
```
git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)
Changes to be committed:
  modified: index.html
```
Если это вас устраивает, и вы убедились, что все, где были конфликты, подготовлено (`staged`), можете ввести `git commit`, чтобы завершить коммит слияния. Комментарий к
коммиту по умолчанию выглядит примерно так:
```
Merge branch 'iss53'
Conflicts:
  index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
# .git/MERGE_HEAD
# and try again.
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
# modified: index.html
#
```
Вы можете дополнить это сообщение подробностями того, как были разрешены конфликты,если считаете, что это поможет другим в будущем разобраться в данном слиянии, если это не очевидно: что вы сделали и почему.

### Управление ветками
Теперь, когда вы уже попробовали создавать, объединять и удалять ветки, пора познакомиться с некоторыми инструментами для управления ветками, которые вам пригодятся, когда вы начнёте использовать ветки постоянно.
Команда `git branch` делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток:
```
git branch
  iss53
* master
  testing
```
Обратите внимание на символ `*`, стоящий перед веткой `master`: он указывает на ветку, на которой вы находитесь в настоящий момент (т.е. ветку, на которую указывает `HEAD`). Это означает, что если вы сейчас выполните коммит, ветка `master` переместится вперёд в
соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду `git branch -v`:
```
git branch -v
  iss53 93b412c fix javascript issue
* master 7a98805 Merge branch 'iss53'
  testing 782fd34 add scott to the author list in the readmes
```
Ещё одна полезная возможность для выяснения состояния веток состоит в том, чтобы оставить в этом списке только те ветки, которые вы слили (или не слили) в ветку, на которой сейчас находитесь. Для этих целей в **Git’е** есть опции `--merged` и `--no-merged`. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду `
```
git branch --merged
git branch --no-merged
  iss53
* master
```
Из-за того, что вы ранее слили `iss53`, она присутствует в этом списке. Те ветки из этого списка, перед которыми нет символа `*`, можно смело удалять командой `git branch -d`; наработки из этих веток уже включены в другую ветку, так что ничего не потеряется.
Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду `git branch --no-merged`:
```
git branch --no-merged
  testing
```
Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой `git branch -d` приведет к ошибке:
```
git branch -d testing
error: The branch 'testing' is not fully merged.
If you are sure you want to delete it, run 'git branch -D testing'.
```
Если вы действительно хотите удалить ветку и потерять наработки, вы можете сделать это при помощи опции `-D`, как указано в подсказке.
## Работа с ветками
Теперь, когда вы познакомились с основами ветвления и слияния. Возникает вопрос: что еще можно делать с ветками? В этом разделе мы разберем некоторые стандартные рабочие примеры, ставшие возможными благодаря облегченной процедуре ветвления. Возможно, что-то из этого вы сможете включить в собственный цикл разработки.
### Основы ветвления
Предположим, вы работаете над проектом и уже имеете несколько коммитов.
Вы решаете, что теперь вы будете заниматься проблемой `#53` из вашей системы отслеживания ошибок. Чтобы создать ветку и сразу переключиться на нее, можно выполнить команду `git checkout` с параметром `-b`:
```
git checkout -b iss53
Switched to a new branch "iss53"
```
Это тоже самое что и:
```
git branch iss53
git checkout iss53
```
Вы работаете над своим сайтом и делаете коммиты. Это приводит к тому, что ветка `iss53` движется вперед, так как вы переключились на нее ранее (`HEAD` указывает на нее).
```
vim index.html
git commit -a -m 'added a new footer [issue 53]'
```
Тут вы получаете сообщение об обнаружении уязвимости на вашем сайте, которую нужно немедленно устранить. Благодаря **Git**, не требуется размещать это исправление вместе с тем, что вы сделали в `iss53`. Вам даже не придется прилагать усилий, чтобы откатить все эти изменения для начала работы над исправлением. Все, что вам нужно — переключиться
на ветку `master`.
Но перед тем как сделать это — имейте в виду, что если ваш рабочий каталог либо область
подготовленных файлов содержат изменения, не попавшие в коммит и конфликтующие с веткой, на которую вы хотите переключиться, то **Git** не позволит вам переключить ветки.
Лучше всего переключаться из чистого рабочего состояния проекта. Есть способы обойти это (спрятать (`stash`) или исправить (`amend`) коммиты), но об этом мы поговорим позже в главе Прибережение и очистка. Теперь предположим, что вы зафиксировали все свои изменения и можете переключиться на основную ветку:
```
git checkout master
Switched to branch 'master'
```
С этого момента ваш рабочий каталог имеет точно такой же вид, какой был перед началом работы над проблемой `#53`. Теперь вы можете сосредоточиться на работе над исправлением.
Важно запомнить: когда вы переключаете ветки, **Git** возвращает состояние рабочего каталога к тому виду, какой он имел в момент последнего коммита в эту ветку. Он добавляет, удаляет и изменяет файлы автоматически, чтобы состояние рабочего каталога соответствовало тому, когда был сделан последний коммит.
Теперь вы можете перейти к написанию исправления. Давайте создадим новую ветку для исправления, в которой будем работать, пока не закончим исправление.
```
git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)
```
Вы можете прогнать тесты, чтобы убедиться, что ваше исправление делает именно то, что нужно. И если это так — выполнить слияние (`merge`) с основной веткой для включения в продукт. Это делается командой `git merge`:
```
git checkout master
git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
```
Заметили фразу “`fast-forward`” в этом слиянии? Из-за того, что коммит, на который указывала ветка, которую вы слили, был прямым потомком того коммита, на котором вы находились, **Git** просто переместил указатель ветки вперед. Другими словами, если коммит
сливается с тем, до которого можно добраться, двигаясь по истории прямо, **Git** упрощает слияние, просто перенося указатель метки вперед (так как нет разветвления в работе). Это называется `fast-forward` (перемотка). Теперь ваши изменения — в снимке (`snapshot`) коммита, на который указывает ветка `master`, и исправления продукта можно внедрять.
После внедрения вашего архиважного исправления вы готовы вернуться к работе над тем, что были вынуждены отложить. Но сначала нужно удалить ветку `hotfix`, потому что она больше не нужна — ветка `master` указывает на то же самое место. Для удаления ветки
выполните команду `git branch` с параметром `-d`:
```
git branch -d hotfix
Deleted branch hotfix (3a0874c).
```
Теперь вы можете переключить ветку и вернуться к работе над своей проблемой `#53`:
```
git checkout iss53
Switched to branch "iss53"
$ vim index.html
git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
```
Стоит обратить внимание на то, что все изменения из ветки `hotfix` не включены в вашу
ветку `iss53`. Если их нужно включить, вы можете влить ветку `master` в вашу ветку `iss53`
командой `git merge master`, или же вы можете отложить слияние этих изменений до
завершения работы, и затем влить ветку `iss53` в `master`.

### Долгоживущие ветки
Так как в **Git** применяется простое трехэтапное слияние, ничто не мешает многократно объединять ветки в течении длительного времени. То есть у вас может быть несколько постоянно открытых веток, применяемых для разных этапов цикла разработки.
Содержимое некоторых из них будет регулярно сливаться в другие ветки.
Многие разработчики, использующие **Git**, придерживаются именно такого подхода, оставляя полностью стабильный код только в ветке `master`. При этом существует и параллельная ветка с именем `develop` или `next`, служащая для работы и тестирования стабильности. После достижения стабильного результата ее содержимое сливается в ветку
`master`. Она используется для объединения завершенных задач из тематических веток (временных веток наподобие iss53), чтобы гарантировать, что эти задачи проходят тестирование и не вносят ошибок.
По сути, мы рассматриваем указатели, перемещающиеся по линии фиксируемых нами изменений. Стабильные ветки находятся в нижнем конце истории коммитов, а самые свежие наработки — ближе к ее верхней части.
В общем случае можно представить набор рабочих накопителей, в котором наборы коммитов перемещаются на более стабильный уровень только после полного тестирования.
Число уровней стабильности можно увеличить. В крупных проектах зачастую появляется ветка `proposed` или `pu` `(proposed updates)`, объединяющая ветки с содержимым, которое невозможно включить в ветку `next` или `master`. Фактически каждая ветка представляет собственный уровень стабильности. Как только он повышается, содержимое сливается в
ветку, расположенную выше. Разумеется, можно и вообще обойтись без долгоживущих веток, но зачастую они имеют смысл, особенно при работе над большими и сложными проектами.
### Тематические ветки
А вот такая вещь, как тематические ветки, полезна вне зависимости от величины проекта.
Тематической `(topic branch)` называется временная ветка, создаваемая и используемая для работы над конкретной функциональной возможностью или решения сопутствующих задач. Скорее всего, при работе с другими `СКВ` вы никогда ничего подобного не делали, так как там создание и слияние веток — затратные операции. Но в **Git** принято много раз в день создавать ветки, работать с ними, сливать их и удалять.
Пример тематических веток вы видели в предыдущем разделе, когда мы создавали ветки `iss53` и `hotfix`. Для каждой из них было выполнено несколько коммитов, после чего сразу же после слияния с основной веткой они были удалены. Такая техника позволяет быстро и радикально осуществлять переключения контекста. Работа разделена по уровням, и все изменения в конкретной ветке относятся к определенной теме, а значит, во время просмотра кода проще понять, что и где было сделано. Ветку с внесенными в нее изменениями можно хранить минуты, дни или даже месяцы, и выполнять ее слияние, только когда это действительно требуется, независимо от порядка создания веток в рамках
проекта и порядка работы с ними.
Предположим, мы работаем в ветке `master`, ответвляемся для решения попутной проблемы (iss91), некоторое время занимаемся ею, затем создаем ветку, чтобы попробовать решить эту задачу другим способом (iss91v2), возвращаемся в ветку `master`, выполняем там некие действия и создаем новую ветку для действий, в результате которых не уверены (ветка dumbidea). 


## 9.Удалённые ветки
Удалённые ветки — это ссылки `(pointers)` на состояние веток в ваших удалённых репозиториях. Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети. Удалённые ветки
действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.
Они выглядят как `(имя удал. репоз.)/(ветка)`. Например, если вы хотите посмотреть, как выглядела ветка `master` на сервере `origin` во время последнего соединения с ним, проверьте
ветку `origin/master`. Если вы с партнёром работали над одной проблемой, и он выложил ветку `iss53`, у вас может быть своя локальная ветка `iss53`; но та ветка на сервере будет
указывать на коммит в `origin/iss53`.
Всё это, возможно, сбивает с толку, поэтому давайте рассмотрим пример. Скажем, у вас в сети есть свой **Git**`-сервер` на `git.ourcompany.com.` Если вы с него что-то склонируете, **Git** команда `clone` автоматически назовёт его `origin`, заберёт оттуда все данные, создаст указатель на то, на что там указывает ветка `master`, и назовёт его локально `origin/master. **Git**`
также сделает вам вашу собственную локальную ветку `master`, которая будет начинаться там же, где и ветка `master` в `origin`, так что вам будет с чем работать.
`“origin”` — это не специальное название.
Подобно тому, как название ветки `“master”` не имеет какого-либо
специального значения в **Git**, также и название `“origin”`. В то время как
`“master”` — это название по умолчанию для исходной ветки, когда вы
запускаете `git init`, по единственной причине, что широко используется, `“origin”` — это название по умолчанию для удаленной ветки, когда вы запускаете `git clone`. Если вы запустите `git clone -o booyah`, так вы будете иметь `booyah/master` как вашу удаленную ветку по умолчанию.
Если вы сделаете что-то в своей локальной ветке `master`, а тем временем кто-то ещё отправит `(push)` изменения на `git.ourcompany.com` и обновит там ветку `master`, то ваши
истории продолжатся по-разному. Ещё, до тех пор, пока вы не свяжетесь с сервером `origin`, ваш указатель `origin/master` не будет сдвигаться.
Для синхронизации вашей работы выполняется команда `git fetch origin`. Эта команда ищет, какому серверу соответствует `“origin”` (в нашем случае это `git.ourcompany.com`); извлекает оттуда все данные, которых у вас ещё нет, и обновляет ваше локальное хранилище данных; сдвигает указатель `origin/master` на новую позицию.
```
 git fetch обновляет ваши удаленные ссылки
```

Чтобы продемонстрировать то, как будут выглядеть удалённые ветки в ситуации с несколькими удалёнными серверами, предположим, что у вас есть ещё один внутренний `**Git**-сервер`, который используется для разработки только одной из ваших команд разработчиков. Этот сервер находится на `git.team1.ourcompany.com.` Вы можете добавить его в
качестве новой удалённой ссылки на проект, над которым вы сейчас работаете с помощью команды `git remote add` так же, как было описано в Основы **Git**. Дайте этому удалённому серверу имя `teamone`, которое будет сокращением для полного URL.
Теперь можете выполнить `git fetch teamone`, чтобы извлечь всё, что есть на сервере и нет у вас. Так как в данный момент на этом сервере есть только часть данных, которые есть на
сервере `origin`, **Git** не получает никаких данных, но выставляет удалённую ветку с именем `teamone/master`, которая указывает на тот же коммит, что и ветка `master` на сервере `teamone`.











































  






